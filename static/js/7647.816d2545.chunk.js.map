{"version":3,"file":"static/js/7647.816d2545.chunk.js","mappings":"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","sources":["../node_modules/decode-named-character-reference/index.dom.js","../node_modules/mdast-util-phrasing/lib/index.js","../node_modules/mdast-util-to-markdown/lib/handle/inline-code.js","../node_modules/mdast-util-to-markdown/lib/handle/list-item.js","../node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js","../node_modules/mdast-util-to-markdown/lib/util/association.js","../node_modules/mdast-util-to-markdown/lib/util/check-bullet.js","../node_modules/mdast-util-to-markdown/lib/util/container-flow.js","../node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js","../node_modules/mdast-util-to-markdown/lib/util/indent-lines.js","../node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js","../node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","../node_modules/mdast-util-to-markdown/lib/util/safe.js","../node_modules/mdast-util-to-markdown/lib/util/track.js","../node_modules/mdast-util-to-string/lib/index.js","../node_modules/micromark-util-decode-numeric-character-reference/index.js","../node_modules/micromark-util-decode-string/index.js","../node_modules/mdast-util-to-markdown/lib/configure.js","../node_modules/mdast-util-to-markdown/lib/handle/blockquote.js","../node_modules/mdast-util-to-markdown/lib/handle/break.js","../node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js","../node_modules/mdast-util-to-markdown/lib/handle/code.js","../node_modules/mdast-util-to-markdown/lib/util/check-quote.js","../node_modules/mdast-util-to-markdown/lib/handle/emphasis.js","../node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js","../node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js","../node_modules/mdast-util-to-markdown/lib/handle/html.js","../node_modules/mdast-util-to-markdown/lib/handle/image.js","../node_modules/mdast-util-to-markdown/lib/handle/image-reference.js","../node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js","../node_modules/mdast-util-to-markdown/lib/handle/link.js","../node_modules/mdast-util-to-markdown/lib/handle/link-reference.js","../node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js","../node_modules/mdast-util-to-markdown/lib/util/check-rule.js","../node_modules/mdast-util-to-markdown/lib/handle/strong.js","../node_modules/mdast-util-to-markdown/lib/util/check-strong.js","../node_modules/mdast-util-to-markdown/lib/handle/index.js","../node_modules/mdast-util-to-markdown/lib/util/check-fence.js","../node_modules/longest-streak/index.js","../node_modules/mdast-util-to-markdown/lib/handle/definition.js","../node_modules/mdast-util-to-markdown/lib/handle/heading.js","../node_modules/mdast-util-to-markdown/lib/handle/list.js","../node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered-other.js","../node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js","../node_modules/mdast-util-to-markdown/lib/handle/paragraph.js","../node_modules/mdast-util-to-markdown/lib/handle/root.js","../node_modules/mdast-util-to-markdown/lib/handle/text.js","../node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js","../node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js","../node_modules/mdast-util-to-markdown/lib/join.js","../node_modules/mdast-util-to-markdown/lib/unsafe.js","../node_modules/mdast-util-to-markdown/lib/index.js","../node_modules/remark-stringify/lib/index.js"],"sourcesContent":["/// <reference lib=\"dom\" />\n\n/* eslint-env browser */\n\nconst element = document.createElement('i')\n\n/**\n * @param {string} value\n * @returns {string|false}\n */\nexport function decodeNamedCharacterReference(value) {\n  const characterReference = '&' + value + ';'\n  element.innerHTML = characterReference\n  const char = element.textContent\n\n  // Some named character references do not require the closing semicolon\n  // (`&not`, for instance), which leads to situations where parsing the assumed\n  // named reference of `&notit;` will result in the string `¬it;`.\n  // When we encounter a trailing semicolon after parsing, and the character\n  // reference to decode was not a semicolon (`&semi;`), we can assume that the\n  // matching was not complete.\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n  // yield `null`.\n  if (char.charCodeAt(char.length - 1) === 59 /* `;` */ && value !== 'semi') {\n    return false\n  }\n\n  // If the decoded string is equal to the input, the character reference was\n  // not valid.\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n  // yield `null`.\n  return char === characterReference ? false : char\n}\n","/**\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('unist-util-is').AssertPredicate<PhrasingContent>} AssertPredicatePhrasing\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Check if the given value is *phrasing content*.\n *\n * @param\n *   Thing to check, typically `Node`.\n * @returns\n *   Whether `value` is phrasing content.\n */\nexport const phrasing = /** @type {AssertPredicatePhrasing} */ (\n  convert([\n    'break',\n    'delete',\n    'emphasis',\n    'footnote',\n    'footnoteReference',\n    'image',\n    'imageReference',\n    'inlineCode',\n    'link',\n    'linkReference',\n    'strong',\n    'text'\n  ])\n)\n","/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\n\nimport {patternCompile} from '../util/pattern-compile.js'\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n","/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\n\n/**\n * @param {ListItem} node\n * @param {Parent | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state)\n  let bullet = state.bulletCurrent || checkBullet(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\n */\nexport function checkListItemIndent(state) {\n  const style = state.options.listItemIndent || 'tab'\n\n  // To do: remove in a major.\n  // @ts-expect-error: deprecated.\n  if (style === 1 || style === '1') {\n    return 'one'\n  }\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","/**\n * @typedef {import('../types.js').AssociationId} AssociationId\n */\n\nimport {decodeString} from 'micromark-util-decode-string'\n\n/**\n * Get an identifier from an association to match it to others.\n *\n * Associations are nodes that match to something else through an ID:\n * <https://github.com/syntax-tree/mdast#association>.\n *\n * The `label` of an association is the string value: character escapes and\n * references work, and casing is intact.\n * The `identifier` is used to match one association to another:\n * controversially, character escapes and references don’t work in this\n * matching: `&copy;` does not match `©`, and `\\+` does not match `+`.\n *\n * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\n * matches `a b`.\n * So, we do prefer the label when figuring out how we’re going to serialize:\n * it has whitespace, casing, and we can ignore most useless character\n * escapes and all character references.\n *\n * @type {AssociationId}\n */\nexport function association(node) {\n  if (node.label || !node.identifier) {\n    return node.label || ''\n  }\n\n  return decodeString(node.identifier)\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBullet(state) {\n  const marker = state.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('../types.js').FlowContent} FlowContent\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').TrackFields} TrackFields\n */\n\n/**\n * @param {Parent & {children: Array<FlowContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nexport function containerFlow(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  const tracker = state.createTracker(info)\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    indexStack[indexStack.length - 1] = index\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          before: '\\n',\n          after: '\\n',\n          ...tracker.current()\n        })\n      )\n    )\n\n    if (child.type !== 'list') {\n      state.bulletLastUsed = undefined\n    }\n\n    if (index < children.length - 1) {\n      results.push(\n        tracker.move(between(child, children[index + 1], parent, state))\n      )\n    }\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n\n/**\n * @param {Node} left\n * @param {Node} right\n * @param {Parent} parent\n * @param {State} state\n * @returns {string}\n */\nfunction between(left, right, parent, state) {\n  let index = state.join.length\n\n  while (index--) {\n    const result = state.join[index](left, right, parent, state)\n\n    if (result === true || result === 1) {\n      break\n    }\n\n    if (typeof result === 'number') {\n      return '\\n'.repeat(1 + result)\n    }\n\n    if (result === false) {\n      return '\\n\\n<!---->\\n\\n'\n    }\n  }\n\n  return '\\n\\n'\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').PhrasingContent} PhrasingContent\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nexport function containerPhrasing(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n  let before = info.before\n\n  indexStack.push(-1)\n  let tracker = state.createTracker(info)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = state.handle.handlers[children[index + 1].type]\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, state, {\n            before: '',\n            after: '',\n            ...tracker.current()\n          }).charAt(0)\n        : ''\n    } else {\n      after = info.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n\n      // To do: does this work to reset tracker?\n      tracker = state.createTracker(info)\n      tracker.move(results.join(''))\n    }\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          ...tracker.current(),\n          before,\n          after\n        })\n      )\n    )\n\n    before = results[results.length - 1].slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n","/**\n * @typedef {import('../types.js').IndentLines} IndentLines\n */\n\nconst eol = /\\r?\\n|\\r/g\n\n/**\n * @type {IndentLines}\n */\nexport function indentLines(value, map) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  let line = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = eol.exec(value))) {\n    one(value.slice(start, match.index))\n    result.push(match[0])\n    start = match.index + match[0].length\n    line++\n  }\n\n  one(value.slice(start))\n\n  return result.join('')\n\n  /**\n   * @param {string} value\n   */\n  function one(value) {\n    result.push(map(value, line, !value))\n  }\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Unsafe} pattern\n * @returns {RegExp}\n */\nexport function patternCompile(pattern) {\n  if (!pattern._compiled) {\n    const before =\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n * @typedef {import('../types.js').ConstructName} ConstructName\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').SafeConfig} SafeConfig\n */\n\nimport {patternCompile} from './pattern-compile.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {string | null | undefined} input\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nexport function safe(state, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n\n    if (!patternInScope(state.stack, pattern)) {\n      continue\n    }\n\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\n      )\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n","/**\n * @typedef {import('../types.js').CreateTracker} CreateTracker\n * @typedef {import('../types.js').TrackCurrent} TrackCurrent\n * @typedef {import('../types.js').TrackMove} TrackMove\n * @typedef {import('../types.js').TrackShift} TrackShift\n */\n\n/**\n * Track positional info in the output.\n *\n * @type {CreateTracker}\n */\nexport function track(config) {\n  // Defaults are used to prevent crashes when older utilities somehow activate\n  // this code.\n  /* c8 ignore next 5 */\n  const options = config || {}\n  const now = options.now || {}\n  let lineShift = options.lineShift || 0\n  let line = now.line || 1\n  let column = now.column || 1\n\n  return {move, current, shift}\n\n  /**\n   * Get the current tracked info.\n   *\n   * @type {TrackCurrent}\n   */\n  function current() {\n    return {now: {line, column}, lineShift}\n  }\n\n  /**\n   * Define an increased line shift (the typical indent for lines).\n   *\n   * @type {TrackShift}\n   */\n  function shift(value) {\n    lineShift += value\n  }\n\n  /**\n   * Move past some generated markdown.\n   *\n   * @type {TrackMove}\n   */\n  function move(input) {\n    // eslint-disable-next-line unicorn/prefer-default-parameters\n    const value = input || ''\n    const chunks = value.split(/\\r?\\n|\\r/g)\n    const tail = chunks[chunks.length - 1]\n    line += chunks.length - 1\n    column =\n      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift\n    return value\n  }\n}\n","/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s.\n * @property {boolean | null | undefined} [includeHtml=true]\n *   Whether to use `value` of HTML.\n */\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the node’s plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} value\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const settings = options || emptyOptions\n  const includeImageAlt =\n    typeof settings.includeImageAlt === 'boolean'\n      ? settings.includeImageAlt\n      : true\n  const includeHtml =\n    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true\n\n  return one(value, includeImageAlt, includeHtml)\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if ('value' in value) {\n      return value.type === 'html' && !includeHtml ? '' : value.value\n    }\n\n    if (includeImageAlt && 'alt' in value && value.alt) {\n      return value.alt\n    }\n\n    if ('children' in value) {\n      return all(value.children, includeImageAlt, includeHtml)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml)\n  }\n\n  return ''\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt, includeHtml) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt, includeHtml)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Node}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n","/**\n * Turn the number (in string form as either hexa- or plain decimal) coming from\n * a numeric character reference into a character.\n *\n * Sort of like `String.fromCharCode(Number.parseInt(value, base))`, but makes\n * non-characters and control characters safe.\n *\n * @param {string} value\n *   Value to decode.\n * @param {number} base\n *   Numeric base.\n * @returns {string}\n *   Character.\n */\nexport function decodeNumericCharacterReference(value, base) {\n  const code = Number.parseInt(value, base)\n  if (\n    // C0 except for HT, LF, FF, CR, space.\n    code < 9 ||\n    code === 11 ||\n    (code > 13 && code < 32) ||\n    // Control character (DEL) of C0, and C1 controls.\n    (code > 126 && code < 160) ||\n    // Lone high surrogates and low surrogates.\n    (code > 55295 && code < 57344) ||\n    // Noncharacters.\n    (code > 64975 && code < 65008) /* eslint-disable no-bitwise */ ||\n    (code & 65535) === 65535 ||\n    (code & 65535) === 65534 /* eslint-enable no-bitwise */ ||\n    // Out of range\n    code > 1114111\n  ) {\n    return '\\uFFFD'\n  }\n  return String.fromCharCode(code)\n}\n","import {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nconst characterEscapeOrReference =\n  /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi\n\n/**\n * Decode markdown strings (which occur in places such as fenced code info\n * strings, destinations, labels, and titles).\n *\n * The “string” content type allows character escapes and -references.\n * This decodes those.\n *\n * @param {string} value\n *   Value to decode.\n * @returns {string}\n *   Decoded value.\n */\nexport function decodeString(value) {\n  return value.replace(characterEscapeOrReference, decode)\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @param {string} $2\n * @returns {string}\n */\nfunction decode($0, $1, $2) {\n  if ($1) {\n    // Escape.\n    return $1\n  }\n\n  // Reference.\n  const head = $2.charCodeAt(0)\n  if (head === 35) {\n    const head = $2.charCodeAt(1)\n    const hex = head === 120 || head === 88\n    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10)\n  }\n  return decodeNamedCharacterReference($2) || $0\n}\n","/**\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').State} State\n */\n\n/**\n * @param {State} base\n * @param {Options} extension\n * @returns {State}\n */\nexport function configure(base, extension) {\n  let index = -1\n  /** @type {keyof Options} */\n  let key\n\n  // First do subextensions.\n  if (extension.extensions) {\n    while (++index < extension.extensions.length) {\n      configure(base, extension.extensions[index])\n    }\n  }\n\n  for (key in extension) {\n    if (key === 'extensions') {\n      // Empty.\n    } else if (key === 'unsafe' || key === 'join') {\n      /* c8 ignore next 2 */\n      // @ts-expect-error: hush.\n      base[key] = [...(base[key] || []), ...(extension[key] || [])]\n    } else if (key === 'handlers') {\n      base[key] = Object.assign(base[key], extension[key] || {})\n    } else {\n      // @ts-expect-error: hush.\n      base.options[key] = extension[key]\n    }\n  }\n\n  return base\n}\n","/**\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n */\n\n/**\n * @param {Blockquote} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function blockquote(node, _, state, info) {\n  const exit = state.enter('blockquote')\n  const tracker = state.createTracker(info)\n  tracker.move('> ')\n  tracker.shift(2)\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return '>' + (blank ? '' : ' ') + line\n}\n","/**\n * @typedef {import('mdast').Break} Break\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {patternInScope} from '../util/pattern-in-scope.js'\n\n/**\n * @param {Break} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function hardBreak(_, _1, state, info) {\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    // If we can’t put eols in this construct (setext headings, tables), use a\n    // space instead.\n    if (\n      state.unsafe[index].character === '\\n' &&\n      patternInScope(state.stack, state.unsafe[index])\n    ) {\n      return /[ \\t]/.test(info.before) ? '' : ' '\n    }\n  }\n\n  return '\\\\\\n'\n}\n","/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {Code} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatCodeAsIndented(node, state) {\n  return Boolean(\n    !state.options.fences &&\n      node.value &&\n      // If there’s no info…\n      !node.lang &&\n      // And there’s a non-whitespace character…\n      /[^ \\r\\n]/.test(node.value) &&\n      // And the value doesn’t start or end in a blank…\n      !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\n  )\n}\n","/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {formatCodeAsIndented} from '../util/format-code-as-indented.js'\nimport {checkFence} from '../util/check-fence.js'\n\n/**\n * @param {Code} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function code(node, _, state, info) {\n  const marker = checkFence(state)\n  const raw = node.value || ''\n  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'\n\n  if (formatCodeAsIndented(node, state)) {\n    const exit = state.enter('codeIndented')\n    const value = state.indentLines(raw, map)\n    exit()\n    return value\n  }\n\n  const tracker = state.createTracker(info)\n  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3))\n  const exit = state.enter('codeFenced')\n  let value = tracker.move(sequence)\n\n  if (node.lang) {\n    const subexit = state.enter(`codeFencedLang${suffix}`)\n    value += tracker.move(\n      state.safe(node.lang, {\n        before: value,\n        after: ' ',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  if (node.lang && node.meta) {\n    const subexit = state.enter(`codeFencedMeta${suffix}`)\n    value += tracker.move(' ')\n    value += tracker.move(\n      state.safe(node.meta, {\n        before: value,\n        after: '\\n',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  value += tracker.move('\\n')\n\n  if (raw) {\n    value += tracker.move(raw + '\\n')\n  }\n\n  value += tracker.move(sequence)\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['quote'], null | undefined>}\n */\nexport function checkQuote(state) {\n  const marker = state.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkEmphasis} from '../util/check-emphasis.js'\n\nemphasis.peek = emphasisPeek\n\n// To do: there are cases where emphasis cannot “form” depending on the\n// previous or next character of sequences.\n// There’s no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @param {Emphasis} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function emphasis(node, _, state, info) {\n  const marker = checkEmphasis(state)\n  const exit = state.enter('emphasis')\n  const tracker = state.createTracker(info)\n  let value = tracker.move(marker)\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker)\n  exit()\n  return value\n}\n\n/**\n * @param {Emphasis} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction emphasisPeek(_, _1, state) {\n  return state.options.emphasis || '*'\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['emphasis'], null | undefined>}\n */\nexport function checkEmphasis(state) {\n  const marker = state.options.emphasis || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize emphasis with `' +\n        marker +\n        '` for `options.emphasis`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../types.js').State} State\n */\n\nimport {visit, EXIT} from 'unist-util-visit'\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Heading} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatHeadingAsSetext(node, state) {\n  let literalWithBreak = false\n\n  // Look for literals with a line break.\n  // Note that this also\n  visit(node, (node) => {\n    if (\n      ('value' in node && /\\r?\\n|\\r/.test(node.value)) ||\n      node.type === 'break'\n    ) {\n      literalWithBreak = true\n      return EXIT\n    }\n  })\n\n  return Boolean(\n    (!node.depth || node.depth < 3) &&\n      toString(node) &&\n      (state.options.setext || literalWithBreak)\n  )\n}\n","/**\n * @typedef {import('mdast').HTML} HTML\n */\n\nhtml.peek = htmlPeek\n\n/**\n * @param {HTML} node\n * @returns {string}\n */\nexport function html(node) {\n  return node.value || ''\n}\n\n/**\n * @returns {string}\n */\nfunction htmlPeek() {\n  return '<'\n}\n","/**\n * @typedef {import('mdast').Image} Image\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\nimage.peek = imagePeek\n\n/**\n * @param {Image} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function image(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('image')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  value += tracker.move(\n    state.safe(node.alt, {before: value, after: ']', ...tracker.current()})\n  )\n  value += tracker.move('](')\n\n  subexit()\n\n  if (\n    // If there’s no url but there is a title…\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n  exit()\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imagePeek() {\n  return '!'\n}\n","/**\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimageReference.peek = imageReferencePeek\n\n/**\n * @param {ImageReference} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function imageReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('imageReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  const alt = state.safe(node.alt, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(alt + '][')\n\n  subexit()\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !alt || alt !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imageReferencePeek() {\n  return '!'\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../types.js').State} State\n */\n\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Link} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatLinkAsAutolink(node, state) {\n  const raw = toString(node)\n\n  return Boolean(\n    !state.options.resourceLink &&\n      // If there’s a url…\n      node.url &&\n      // And there’s a no title…\n      !node.title &&\n      // And the content of `node` is a single text node…\n      node.children &&\n      node.children.length === 1 &&\n      node.children[0].type === 'text' &&\n      // And if the url is the same as the content…\n      (raw === node.url || 'mailto:' + raw === node.url) &&\n      // And that starts w/ a protocol…\n      /^[a-z][a-z+.-]+:/i.test(node.url) &&\n      // And that doesn’t contain ASCII control codes (character escapes and\n      // references don’t work), space, or angle brackets…\n      !/[\\0- <>\\u007F]/.test(node.url)\n  )\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Exit} Exit\n */\n\nimport {checkQuote} from '../util/check-quote.js'\nimport {formatLinkAsAutolink} from '../util/format-link-as-autolink.js'\n\nlink.peek = linkPeek\n\n/**\n * @param {Link} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function link(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const tracker = state.createTracker(info)\n  /** @type {Exit} */\n  let exit\n  /** @type {Exit} */\n  let subexit\n\n  if (formatLinkAsAutolink(node, state)) {\n    // Hide the fact that we’re in phrasing, because escapes don’t work.\n    const stack = state.stack\n    state.stack = []\n    exit = state.enter('autolink')\n    let value = tracker.move('<')\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: '>',\n        ...tracker.current()\n      })\n    )\n    value += tracker.move('>')\n    exit()\n    state.stack = stack\n    return value\n  }\n\n  exit = state.enter('link')\n  subexit = state.enter('label')\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: '](',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move('](')\n  subexit()\n\n  if (\n    // If there’s no url but there is a title…\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n\n  exit()\n  return value\n}\n\n/**\n * @param {Link} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @returns {string}\n */\nfunction linkPeek(node, _, state) {\n  return formatLinkAsAutolink(node, state) ? '<' : '['\n}\n","/**\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nlinkReference.peek = linkReferencePeek\n\n/**\n * @param {LinkReference} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function linkReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('linkReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  const text = state.containerPhrasing(node, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(text + '][')\n\n  subexit()\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !text || text !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction linkReferencePeek() {\n  return '['\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrdered(state) {\n  const marker = state.options.bulletOrdered || '.'\n\n  if (marker !== '.' && marker !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bulletOrdered`, expected `.` or `)`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['rule'], null | undefined>}\n */\nexport function checkRule(state) {\n  const marker = state.options.rule || '*'\n\n  if (marker !== '*' && marker !== '-' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize rules with `' +\n        marker +\n        '` for `options.rule`, expected `*`, `-`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkStrong} from '../util/check-strong.js'\n\nstrong.peek = strongPeek\n\n// To do: there are cases where emphasis cannot “form” depending on the\n// previous or next character of sequences.\n// There’s no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @param {Strong} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function strong(node, _, state, info) {\n  const marker = checkStrong(state)\n  const exit = state.enter('strong')\n  const tracker = state.createTracker(info)\n  let value = tracker.move(marker + marker)\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker + marker)\n  exit()\n  return value\n}\n\n/**\n * @param {Strong} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction strongPeek(_, _1, state) {\n  return state.options.strong || '*'\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['strong'], null | undefined>}\n */\nexport function checkStrong(state) {\n  const marker = state.options.strong || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize strong with `' +\n        marker +\n        '` for `options.strong`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {definition} from './definition.js'\nimport {emphasis} from './emphasis.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {image} from './image.js'\nimport {imageReference} from './image-reference.js'\nimport {inlineCode} from './inline-code.js'\nimport {link} from './link.js'\nimport {linkReference} from './link-reference.js'\nimport {list} from './list.js'\nimport {listItem} from './list-item.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default (CommonMark) handlers.\n */\nexport const handle = {\n  blockquote,\n  break: hardBreak,\n  code,\n  definition,\n  emphasis,\n  hardBreak,\n  heading,\n  html,\n  image,\n  imageReference,\n  inlineCode,\n  link,\n  linkReference,\n  list,\n  listItem,\n  paragraph,\n  root,\n  strong,\n  text,\n  thematicBreak\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['fence'], null | undefined>}\n */\nexport function checkFence(state) {\n  const marker = state.options.fence || '`'\n\n  if (marker !== '`' && marker !== '~') {\n    throw new Error(\n      'Cannot serialize code with `' +\n        marker +\n        '` for `options.fence`, expected `` ` `` or `~`'\n    )\n  }\n\n  return marker\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n","/**\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\n/**\n * @param {Definition} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function definition(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('definition')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.safe(state.associationId(node), {\n      before: value,\n      after: ']',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(']: ')\n\n  subexit()\n\n  if (\n    // If there’s no url, or…\n    !node.url ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : '\\n',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  exit()\n\n  return value\n}\n","/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {formatHeadingAsSetext} from '../util/format-heading-as-setext.js'\n\n/**\n * @param {Heading} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function heading(node, _, state, info) {\n  const rank = Math.max(Math.min(6, node.depth || 1), 1)\n  const tracker = state.createTracker(info)\n\n  if (formatHeadingAsSetext(node, state)) {\n    const exit = state.enter('headingSetext')\n    const subexit = state.enter('phrasing')\n    const value = state.containerPhrasing(node, {\n      ...tracker.current(),\n      before: '\\n',\n      after: '\\n'\n    })\n    subexit()\n    exit()\n\n    return (\n      value +\n      '\\n' +\n      (rank === 1 ? '=' : '-').repeat(\n        // The whole size…\n        value.length -\n          // Minus the position of the character after the last EOL (or\n          // 0 if there is none)…\n          (Math.max(value.lastIndexOf('\\r'), value.lastIndexOf('\\n')) + 1)\n      )\n    )\n  }\n\n  const sequence = '#'.repeat(rank)\n  const exit = state.enter('headingAtx')\n  const subexit = state.enter('phrasing')\n\n  // Note: for proper tracking, we should reset the output positions when there\n  // is no content returned, because then the space is not output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  tracker.move(sequence + ' ')\n\n  let value = state.containerPhrasing(node, {\n    before: '# ',\n    after: '\\n',\n    ...tracker.current()\n  })\n\n  if (/^[\\t ]/.test(value)) {\n    // To do: what effect has the character reference on tracking?\n    value =\n      '&#x' +\n      value.charCodeAt(0).toString(16).toUpperCase() +\n      ';' +\n      value.slice(1)\n  }\n\n  value = value ? sequence + ' ' + value : sequence\n\n  if (state.options.closeAtx) {\n    value += ' ' + sequence\n  }\n\n  subexit()\n  exit()\n\n  return value\n}\n","/**\n * @typedef {import('mdast').List} List\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkBulletOther} from '../util/check-bullet-other.js'\nimport {checkBulletOrdered} from '../util/check-bullet-ordered.js'\nimport {checkBulletOrderedOther} from '../util/check-bullet-ordered-other.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {List} node\n * @param {Parent | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function list(node, parent, state, info) {\n  const exit = state.enter('list')\n  const bulletCurrent = state.bulletCurrent\n  /** @type {string} */\n  let bullet = node.ordered ? checkBulletOrdered(state) : checkBullet(state)\n  /** @type {string} */\n  const bulletOther = node.ordered\n    ? checkBulletOrderedOther(state)\n    : checkBulletOther(state)\n  const bulletLastUsed = state.bulletLastUsed\n  let useDifferentMarker = false\n\n  if (\n    parent &&\n    // Explicit `other` set.\n    (node.ordered\n      ? state.options.bulletOrderedOther\n      : state.options.bulletOther) &&\n    bulletLastUsed &&\n    bullet === bulletLastUsed\n  ) {\n    useDifferentMarker = true\n  }\n\n  if (!node.ordered) {\n    const firstListItem = node.children ? node.children[0] : undefined\n\n    // If there’s an empty first list item directly in two list items,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * - *\n    // ```\n    //\n    // …because otherwise it would become one big thematic break.\n    if (\n      // Bullet could be used as a thematic break marker:\n      (bullet === '*' || bullet === '-') &&\n      // Empty first list item:\n      firstListItem &&\n      (!firstListItem.children || !firstListItem.children[0]) &&\n      // Directly in two other list items:\n      state.stack[state.stack.length - 1] === 'list' &&\n      state.stack[state.stack.length - 2] === 'listItem' &&\n      state.stack[state.stack.length - 3] === 'list' &&\n      state.stack[state.stack.length - 4] === 'listItem' &&\n      // That are each the first child.\n      state.indexStack[state.indexStack.length - 1] === 0 &&\n      state.indexStack[state.indexStack.length - 2] === 0 &&\n      state.indexStack[state.indexStack.length - 3] === 0\n    ) {\n      useDifferentMarker = true\n    }\n\n    // If there’s a thematic break at the start of the first list item,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * ---\n    // ```\n    //\n    // …because otherwise it would become one big thematic break.\n    if (checkRule(state) === bullet && firstListItem) {\n      let index = -1\n\n      while (++index < node.children.length) {\n        const item = node.children[index]\n\n        if (\n          item &&\n          item.type === 'listItem' &&\n          item.children &&\n          item.children[0] &&\n          item.children[0].type === 'thematicBreak'\n        ) {\n          useDifferentMarker = true\n          break\n        }\n      }\n    }\n  }\n\n  if (useDifferentMarker) {\n    bullet = bulletOther\n  }\n\n  state.bulletCurrent = bullet\n  const value = state.containerFlow(node, info)\n  state.bulletLastUsed = bullet\n  state.bulletCurrent = bulletCurrent\n  exit()\n  return value\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\nimport {checkBulletOrdered} from './check-bullet-ordered.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrderedOther(state) {\n  const bulletOrdered = checkBulletOrdered(state)\n  const bulletOrderedOther = state.options.bulletOrderedOther\n\n  if (!bulletOrderedOther) {\n    return bulletOrdered === '.' ? ')' : '.'\n  }\n\n  if (bulletOrderedOther !== '.' && bulletOrderedOther !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOrderedOther +\n        '` for `options.bulletOrderedOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOrderedOther === bulletOrdered) {\n    throw new Error(\n      'Expected `bulletOrdered` (`' +\n        bulletOrdered +\n        '`) and `bulletOrderedOther` (`' +\n        bulletOrderedOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOrderedOther\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\nimport {checkBullet} from './check-bullet.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBulletOther(state) {\n  const bullet = checkBullet(state)\n  const bulletOther = state.options.bulletOther\n\n  if (!bulletOther) {\n    return bullet === '*' ? '-' : '*'\n  }\n\n  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOther +\n        '` for `options.bulletOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOther === bullet) {\n    throw new Error(\n      'Expected `bullet` (`' +\n        bullet +\n        '`) and `bulletOther` (`' +\n        bulletOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOther\n}\n","/**\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\n/**\n * @param {Paragraph} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function paragraph(node, _, state, info) {\n  const exit = state.enter('paragraph')\n  const subexit = state.enter('phrasing')\n  const value = state.containerPhrasing(node, info)\n  subexit()\n  exit()\n  return value\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {phrasing} from 'mdast-util-phrasing'\n\n/**\n * @param {Root} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function root(node, _, state, info) {\n  // Note: `html` nodes are ambiguous.\n  const hasPhrasing = node.children.some((d) => phrasing(d))\n  const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow\n  // @ts-expect-error: `root`s are supposed to have one type of content\n  return fn.call(state, node, info)\n}\n","/**\n * @typedef {import('mdast').Text} Text\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\n/**\n * @param {Text} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function text(node, _, state, info) {\n  return state.safe(node.value, info)\n}\n","/**\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkRuleRepetition} from '../util/check-rule-repetition.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {ThematicBreak} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nexport function thematicBreak(_, _1, state) {\n  const value = (\n    checkRule(state) + (state.options.ruleSpaces ? ' ' : '')\n  ).repeat(checkRuleRepetition(state))\n\n  return state.options.ruleSpaces ? value.slice(0, -1) : value\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['ruleRepetition'], null | undefined>}\n */\nexport function checkRuleRepetition(state) {\n  const repetition = state.options.ruleRepetition || 3\n\n  if (repetition < 3) {\n    throw new Error(\n      'Cannot serialize rules with repetition `' +\n        repetition +\n        '` for `options.ruleRepetition`, expected `3` or more'\n    )\n  }\n\n  return repetition\n}\n","/**\n * @typedef {import('./types.js').Join} Join\n */\n\nimport {formatCodeAsIndented} from './util/format-code-as-indented.js'\nimport {formatHeadingAsSetext} from './util/format-heading-as-setext.js'\n\n/** @type {Array<Join>} */\nexport const join = [joinDefaults]\n\n/** @type {Join} */\nfunction joinDefaults(left, right, parent, state) {\n  // Indented code after list or another indented code.\n  if (\n    right.type === 'code' &&\n    formatCodeAsIndented(right, state) &&\n    (left.type === 'list' ||\n      (left.type === right.type && formatCodeAsIndented(left, state)))\n  ) {\n    return false\n  }\n\n  // Two lists with the same marker.\n  if (\n    left.type === 'list' &&\n    left.type === right.type &&\n    Boolean(left.ordered) === Boolean(right.ordered) &&\n    !(left.ordered\n      ? state.options.bulletOrderedOther\n      : state.options.bulletOther)\n  ) {\n    return false\n  }\n\n  // Join children of a list or an item.\n  // In which case, `parent` has a `spread` field.\n  if ('spread' in parent && typeof parent.spread === 'boolean') {\n    if (\n      left.type === 'paragraph' &&\n      // Two paragraphs.\n      (left.type === right.type ||\n        right.type === 'definition' ||\n        // Paragraph followed by a setext heading.\n        (right.type === 'heading' && formatHeadingAsSetext(right, state)))\n    ) {\n      return\n    }\n\n    return parent.spread ? 1 : 0\n  }\n}\n","/**\n * @typedef {import('./types.js').Unsafe} Unsafe\n * @typedef {import('./types.js').ConstructName} ConstructName\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain things like attention (emphasis, strong), images, or links.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * @type {Array<ConstructName>}\n */\nconst fullPhrasingSpans = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\n/** @type {Array<Unsafe>} */\nexport const unsafe = [\n  {character: '\\t', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: '\\t', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: '\\t',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  {\n    character: '\\r',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {\n    character: '\\n',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {character: ' ', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: ' ', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: ' ',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  // An exclamation mark can start an image, if it is followed by a link or\n  // a link reference.\n  {\n    character: '!',\n    after: '\\\\[',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A quote can break out of a title.\n  {character: '\"', inConstruct: 'titleQuote'},\n  // A number sign could start an ATX heading if it starts a line.\n  {atBreak: true, character: '#'},\n  {character: '#', inConstruct: 'headingAtx', after: '(?:[\\r\\n]|$)'},\n  // Dollar sign and percentage are not used in markdown.\n  // An ampersand could start a character reference.\n  {character: '&', after: '[#A-Za-z]', inConstruct: 'phrasing'},\n  // An apostrophe can break out of a title.\n  {character: \"'\", inConstruct: 'titleApostrophe'},\n  // A left paren could break out of a destination raw.\n  {character: '(', inConstruct: 'destinationRaw'},\n  // A left paren followed by `]` could make something into a link or image.\n  {\n    before: '\\\\]',\n    character: '(',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A right paren could start a list item or break out of a destination\n  // raw.\n  {atBreak: true, before: '\\\\d+', character: ')'},\n  {character: ')', inConstruct: 'destinationRaw'},\n  // An asterisk can start thematic breaks, list items, emphasis, strong.\n  {atBreak: true, character: '*', after: '(?:[ \\t\\r\\n*])'},\n  {character: '*', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A plus sign could start a list item.\n  {atBreak: true, character: '+', after: '(?:[ \\t\\r\\n])'},\n  // A dash can start thematic breaks, list items, and setext heading\n  // underlines.\n  {atBreak: true, character: '-', after: '(?:[ \\t\\r\\n-])'},\n  // A dot could start a list item.\n  {atBreak: true, before: '\\\\d+', character: '.', after: '(?:[ \\t\\r\\n]|$)'},\n  // Slash, colon, and semicolon are not used in markdown for constructs.\n  // A less than can start html (flow or text) or an autolink.\n  // HTML could start with an exclamation mark (declaration, cdata, comment),\n  // slash (closing tag), question mark (instruction), or a letter (tag).\n  // An autolink also starts with a letter.\n  // Finally, it could break out of a destination literal.\n  {atBreak: true, character: '<', after: '[!/?A-Za-z]'},\n  {\n    character: '<',\n    after: '[!/?A-Za-z]',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  {character: '<', inConstruct: 'destinationLiteral'},\n  // An equals to can start setext heading underlines.\n  {atBreak: true, character: '='},\n  // A greater than can start block quotes and it can break out of a\n  // destination literal.\n  {atBreak: true, character: '>'},\n  {character: '>', inConstruct: 'destinationLiteral'},\n  // Question mark and at sign are not used in markdown for constructs.\n  // A left bracket can start definitions, references, labels,\n  {atBreak: true, character: '['},\n  {character: '[', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  {character: '[', inConstruct: ['label', 'reference']},\n  // A backslash can start an escape (when followed by punctuation) or a\n  // hard break (when followed by an eol).\n  // Note: typical escapes are handled in `safe`!\n  {character: '\\\\', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  // A right bracket can exit labels.\n  {character: ']', inConstruct: ['label', 'reference']},\n  // Caret is not used in markdown for constructs.\n  // An underscore can start emphasis, strong, or a thematic break.\n  {atBreak: true, character: '_'},\n  {character: '_', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A grave accent can start code (fenced or text), or it can break out of\n  // a grave accent code fence.\n  {atBreak: true, character: '`'},\n  {\n    character: '`',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedMetaGraveAccent']\n  },\n  {character: '`', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // Left brace, vertical bar, right brace are not used in markdown for\n  // constructs.\n  // A tilde can start code (fenced).\n  {atBreak: true, character: '~'}\n]\n","/**\n * @typedef {import('./types.js').Enter} Enter\n * @typedef {import('./types.js').Info} Info\n * @typedef {import('./types.js').Join} Join\n * @typedef {import('./types.js').FlowContent} FlowContent\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').PhrasingContent} PhrasingContent\n * @typedef {import('./types.js').SafeConfig} SafeConfig\n * @typedef {import('./types.js').State} State\n * @typedef {import('./types.js').TrackFields} TrackFields\n */\n\nimport {zwitch} from 'zwitch'\nimport {configure} from './configure.js'\nimport {handle as handlers} from './handle/index.js'\nimport {join} from './join.js'\nimport {unsafe} from './unsafe.js'\nimport {association} from './util/association.js'\nimport {containerPhrasing} from './util/container-phrasing.js'\nimport {containerFlow} from './util/container-flow.js'\nimport {indentLines} from './util/indent-lines.js'\nimport {safe} from './util/safe.js'\nimport {track} from './util/track.js'\n\n/**\n * Turn an mdast syntax tree into markdown.\n *\n * @param {Node} tree\n *   Tree to serialize.\n * @param {Options} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized markdown representing `tree`.\n */\nexport function toMarkdown(tree, options = {}) {\n  /** @type {State} */\n  const state = {\n    enter,\n    indentLines,\n    associationId: association,\n    containerPhrasing: containerPhrasingBound,\n    containerFlow: containerFlowBound,\n    createTracker: track,\n    safe: safeBound,\n    stack: [],\n    unsafe: [],\n    join: [],\n    // @ts-expect-error: we’ll fill it next.\n    handlers: {},\n    options: {},\n    indexStack: [],\n    // @ts-expect-error: we’ll add `handle` later.\n    handle: undefined\n  }\n\n  configure(state, {unsafe, join, handlers})\n  configure(state, options)\n\n  if (state.options.tightDefinitions) {\n    configure(state, {join: [joinDefinition]})\n  }\n\n  state.handle = zwitch('type', {\n    invalid,\n    unknown,\n    handlers: state.handlers\n  })\n\n  let result = state.handle(tree, undefined, state, {\n    before: '\\n',\n    after: '\\n',\n    now: {line: 1, column: 1},\n    lineShift: 0\n  })\n\n  if (\n    result &&\n    result.charCodeAt(result.length - 1) !== 10 &&\n    result.charCodeAt(result.length - 1) !== 13\n  ) {\n    result += '\\n'\n  }\n\n  return result\n\n  /** @type {Enter} */\n  function enter(name) {\n    state.stack.push(name)\n    return exit\n\n    function exit() {\n      state.stack.pop()\n    }\n  }\n}\n\n/**\n * @param {unknown} value\n * @returns {never}\n */\nfunction invalid(value) {\n  throw new Error('Cannot handle value `' + value + '`, expected node')\n}\n\n/**\n * @param {unknown} node\n * @returns {never}\n */\nfunction unknown(node) {\n  // @ts-expect-error: fine.\n  throw new Error('Cannot handle unknown node `' + node.type + '`')\n}\n\n/** @type {Join} */\nfunction joinDefinition(left, right) {\n  // No blank line between adjacent definitions.\n  if (left.type === 'definition' && left.type === right.type) {\n    return 0\n  }\n}\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nfunction containerPhrasingBound(parent, info) {\n  return containerPhrasing(parent, this, info)\n}\n\n/**\n * Serialize the children of a parent that contains flow children.\n *\n * These children will typically be joined by blank lines.\n * What they are joined by exactly is defined by `Join` functions.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parent & {children: Array<FlowContent>}} parent\n *   Parent of flow nodes.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nfunction containerFlowBound(parent, info) {\n  return containerFlow(parent, this, info)\n}\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {string | null | undefined} value\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nfunction safeBound(value, config) {\n  return safe(this, value, config)\n}\n","/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownOptions\n * @typedef {Omit<ToMarkdownOptions, 'extensions'>} Options\n */\n\nimport {toMarkdown} from 'mdast-util-to-markdown'\n\n/**\n * @this {import('unified').Processor}\n * @type {import('unified').Plugin<[Options?]|void[], Node, string>}\n */\nexport default function remarkStringify(options) {\n  /** @type {import('unified').CompilerFunction<Node, string>} */\n  const compiler = (tree) => {\n    // Assume options.\n    const settings = /** @type {Options} */ (this.data('settings'))\n\n    return toMarkdown(\n      tree,\n      Object.assign({}, settings, options, {\n        // Note: this option is not in the readme.\n        // The goal is for it to be set by plugins on `data` instead of being\n        // passed by users.\n        extensions:\n          /** @type {ToMarkdownOptions['extensions']} */ (\n            this.data('toMarkdownExtensions')\n          ) || []\n      })\n    )\n  }\n\n  Object.assign(this, {Compiler: compiler})\n}\n"],"names":["element","document","createElement","decodeNamedCharacterReference","value","characterReference","innerHTML","char","textContent","charCodeAt","length","phrasing","convert","inlineCode","node","_","state","sequence","index","RegExp","test","unsafe","pattern","expression","patternCompile","match","atBreak","exec","position","slice","peek","listItem","parent","info","listItemIndent","style","options","Error","checkListItemIndent","bullet","bulletCurrent","checkBullet","type","ordered","start","incrementListMarker","children","indexOf","size","spread","Math","ceil","tracker","createTracker","move","repeat","shift","exit","enter","indentLines","containerFlow","current","line","blank","association","label","identifier","decodeString","marker","indexStack","results","push","child","handle","before","after","bulletLastUsed","undefined","between","pop","join","left","right","result","containerPhrasing","handlers","charAt","replace","eol","map","one","_compiled","character","patternInScope","stack","listInScope","inConstruct","notInConstruct","list","none","includes","safe","input","config","positions","infos","Boolean","sort","numerical","end","escapeBackslashes","encode","toString","toUpperCase","a","b","whole","track","now","lineShift","column","chunks","split","tail","emptyOptions","settings","includeImageAlt","includeHtml","alt","all","Array","isArray","values","decodeNumericCharacterReference","base","code","Number","parseInt","String","fromCharCode","characterEscapeOrReference","decode","$0","$1","$2","head","hex","configure","extension","key","extensions","Object","assign","hardBreak","_1","formatCodeAsIndented","fences","lang","checkQuote","quote","emphasis","checkEmphasis","formatHeadingAsSetext","literalWithBreak","visit","EXIT","depth","setext","html","image","suffix","subexit","url","title","imageReference","referenceType","reference","associationId","formatLinkAsAutolink","raw","resourceLink","link","linkReference","text","checkBulletOrdered","bulletOrdered","checkRule","rule","strong","checkStrong","blockquote","break","fence","checkFence","max","substring","source","expected","count","TypeError","longestStreak","meta","definition","heading","rank","min","lastIndexOf","closeAtx","bulletOther","bulletOrderedOther","checkBulletOrderedOther","checkBulletOther","useDifferentMarker","firstListItem","item","paragraph","root","some","d","call","thematicBreak","ruleSpaces","repetition","ruleRepetition","checkRuleRepetition","fullPhrasingSpans","invalid","unknown","joinDefinition","containerPhrasingBound","this","containerFlowBound","safeBound","remarkStringify","Compiler","tree","data","arguments","name","tightDefinitions","zwitch","toMarkdown"],"sourceRoot":""}